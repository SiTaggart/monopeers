{"version":3,"sources":["../src/logger.ts","../src/errors.ts","../src/check.ts","../src/sort-deps.ts","../src/get-hoisted-package-peer-deps.ts","../src/utils.ts","../src/get-corrected-package-peers.ts","../src/index.ts"],"sourcesContent":["import chalk from 'chalk';\nimport util from 'node:util';\n\nexport const format = (\n  args: Array<unknown>,\n  messageType: 'error' | 'success' | 'info',\n  scope?: string\n): string => {\n  const prefix = {\n    error: chalk.red('error'),\n    success: chalk.green('success'),\n    info: chalk.cyan('info'),\n  }[messageType];\n  const fullPrefix = ` ${prefix}${scope === undefined ? '' : ` ${scope}`}`;\n  return (\n    fullPrefix +\n    util\n      .format('', ...args)\n      .split('\\n')\n      .join(`\\n ${fullPrefix} `)\n  );\n};\nexport const error = (message: string, scope?: string): void => {\n  console.error(format([message], 'error', scope));\n};\n\nexport const success = (message: string, scope?: string): void => {\n  console.log(format([message], 'success', scope));\n};\n\nexport const info = (message: string, scope?: string): void => {\n  console.log(format([message], 'info', scope));\n};\n","export class ExitError extends Error {\n  code: number;\n\n  constructor(code: number) {\n    super(`The process should exit with code ${code}`);\n    this.code = code;\n  }\n}\n","import { diff } from 'deep-object-diff';\nimport * as logger from './logger';\nimport { getCorrectedPackagePeers } from './get-corrected-package-peers';\nimport { getInternalPackages, transformManyPkgData } from './utils';\n\nexport const check = async (): Promise<void> => {\n  const packages = await getInternalPackages('.');\n  const packageList = transformManyPkgData(packages);\n  const correctedPackageList = getCorrectedPackagePeers(packageList);\n  logger.info(JSON.stringify(diff(packageList, correctedPackageList), undefined, 2));\n};\n","export const sortDeps = (peerList: Record<string, string>): Record<string, string> => {\n  let sortedPeers = {};\n  for (const peer of Object.keys(peerList).sort()) {\n    sortedPeers = {\n      ...sortedPeers,\n      [`${peer}`]: peerList[peer],\n    };\n  }\n  return sortedPeers;\n};\n","import type { PackageList } from './types';\n\nexport const getHoistedPackagePeerDeps = (\n  packageList: PackageList,\n  pkg: string\n): Record<string, string> => {\n  let combinedHoistedPeers = {};\n  const { peerDependencies } = packageList[pkg];\n  if (typeof peerDependencies === 'object') {\n    for (const peer of Object.keys(peerDependencies)) {\n      const peerDepsOfPeer =\n        packageList[peer] && packageList[peer].peerDependencies\n          ? packageList[peer].peerDependencies\n          : {};\n      combinedHoistedPeers = {\n        ...combinedHoistedPeers,\n        ...peerDepsOfPeer,\n        ...peerDependencies,\n      };\n    }\n  }\n  return combinedHoistedPeers;\n};\n","import { getPackages } from '@manypkg/get-packages';\nimport type { Package } from '@manypkg/get-packages';\nimport type { PackageList } from './types';\n\nexport const transformManyPkgData = (packages: Package[]): PackageList => {\n  let result = {};\n  for (const pkg of packages) {\n    result = {\n      ...result,\n      [`${pkg.packageJson.name}`]: {\n        ...(pkg.packageJson.peerDependencies && {\n          peerDependencies: { ...pkg.packageJson.peerDependencies },\n        }),\n        ...(pkg.packageJson.dependencies && { dependencies: { ...pkg.packageJson.dependencies } }),\n        ...(pkg.packageJson.devDependencies && {\n          devDependencies: { ...pkg.packageJson.devDependencies },\n        }),\n      },\n    };\n  }\n\n  return result;\n};\n\nexport const getInternalPackages = async (path: string): Promise<Package[]> => {\n  const { packages } = await getPackages(path);\n  return packages;\n};\n\nexport const getNumberOfPeersByPackage = (pkgs: PackageList, pkg: string): number => {\n  const { peerDependencies } = pkgs[pkg];\n  return typeof peerDependencies === 'object' ? Object.keys(peerDependencies).length : 0;\n};\n\nexport const getInternalPackageNames = (packages: Package[]): string[] =>\n  packages.map((pkg) => pkg.packageJson.name);\n","import { sortDeps } from './sort-deps';\nimport { getHoistedPackagePeerDeps } from './get-hoisted-package-peer-deps';\nimport type { PackageList } from './types';\nimport { getNumberOfPeersByPackage } from './utils';\n\nexport const getCorrectedPackagePeers = (packageList: PackageList): PackageList => {\n  let correctedPackageList = packageList;\n  let needsCorrecting;\n  let hoistedPackagePeers;\n\n  do {\n    needsCorrecting = false;\n\n    for (const pkg of Object.keys(packageList)) {\n      const initialNumberOfPkgPeers = getNumberOfPeersByPackage(correctedPackageList, pkg);\n\n      hoistedPackagePeers = getHoistedPackagePeerDeps(correctedPackageList, pkg);\n      const currentCorrectedPeers = correctedPackageList[pkg].peerDependencies;\n\n      if (\n        typeof currentCorrectedPeers === 'object' &&\n        (Object.keys(currentCorrectedPeers).length > 0 ||\n          Object.keys(hoistedPackagePeers).length > 0)\n      ) {\n        correctedPackageList = {\n          ...correctedPackageList,\n          [pkg]: {\n            peerDependencies: sortDeps({\n              ...currentCorrectedPeers,\n              ...hoistedPackagePeers,\n            }),\n          },\n        };\n      }\n      const newNumberOfPkgPeers = getNumberOfPeersByPackage(correctedPackageList, pkg);\n\n      if (initialNumberOfPkgPeers !== newNumberOfPkgPeers) {\n        needsCorrecting = true;\n      }\n    }\n  } while (needsCorrecting);\n  return correctedPackageList;\n};\n","#!/usr/bin/env node\nimport * as logger from './logger';\nimport { ExitError } from './errors';\nimport { check } from './check';\n\ntry {\n  const args = process.argv.slice(2);\n\n  if (args[0] === 'fix') {\n    logger.info('running the fix');\n  }\n\n  if (args[0] === 'check') {\n    logger.info('running the check');\n    check();\n  }\n\n  if (args[0] !== 'fix' && args[0] !== 'check') {\n    logger.error(`command ${args[0]} not found, only check, and fix are available options`);\n    throw new ExitError(1);\n  }\n  logger.info('running');\n} catch (error) {\n  if (error instanceof ExitError) {\n    process.exit(error.code);\n  } else if (typeof error === 'string') {\n    logger.error(error);\n    process.exit(1);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,mBAAkB;AAClB,uBAAiB;AAEV,IAAM,SAAS,CACpB,MACA,aACA,UACW;AACX,QAAM,SAAS;AAAA,IACb,OAAO,aAAAA,QAAM,IAAI,OAAO;AAAA,IACxB,SAAS,aAAAA,QAAM,MAAM,SAAS;AAAA,IAC9B,MAAM,aAAAA,QAAM,KAAK,MAAM;AAAA,EACzB,EAAE;AACF,QAAM,aAAa,IAAI,SAAS,UAAU,SAAY,KAAK,IAAI;AAC/D,SACE,aACA,iBAAAC,QACG,OAAO,IAAI,GAAG,IAAI,EAClB,MAAM,IAAI,EACV,KAAK;AAAA,GAAM,aAAa;AAE/B;AACO,IAAM,QAAQ,CAAC,SAAiB,UAAyB;AAC9D,UAAQ,MAAM,OAAO,CAAC,OAAO,GAAG,SAAS,KAAK,CAAC;AACjD;AAMO,IAAM,OAAO,CAAC,SAAiB,UAAyB;AAC7D,UAAQ,IAAI,OAAO,CAAC,OAAO,GAAG,QAAQ,KAAK,CAAC;AAC9C;;;AChCO,IAAM,YAAN,cAAwB,MAAM;AAAA,EACnC;AAAA,EAEA,YAAY,MAAc;AACxB,UAAM,qCAAqC,MAAM;AACjD,SAAK,OAAO;AAAA,EACd;AACF;;;ACPA,8BAAqB;;;ACAd,IAAM,WAAW,CAAC,aAA6D;AACpF,MAAI,cAAc,CAAC;AACnB,aAAW,QAAQ,OAAO,KAAK,QAAQ,EAAE,KAAK,GAAG;AAC/C,kBAAc;AAAA,MACZ,GAAG;AAAA,MACH,CAAC,GAAG,SAAS,SAAS;AAAA,IACxB;AAAA,EACF;AACA,SAAO;AACT;;;ACPO,IAAM,4BAA4B,CACvC,aACA,QAC2B;AAC3B,MAAI,uBAAuB,CAAC;AAC5B,QAAM,EAAE,iBAAiB,IAAI,YAAY;AACzC,MAAI,OAAO,qBAAqB,UAAU;AACxC,eAAW,QAAQ,OAAO,KAAK,gBAAgB,GAAG;AAChD,YAAM,iBACJ,YAAY,SAAS,YAAY,MAAM,mBACnC,YAAY,MAAM,mBAClB,CAAC;AACP,6BAAuB;AAAA,QACrB,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;;;ACtBA,0BAA4B;AAIrB,IAAM,uBAAuB,CAAC,aAAqC;AACxE,MAAI,SAAS,CAAC;AACd,aAAW,OAAO,UAAU;AAC1B,aAAS;AAAA,MACP,GAAG;AAAA,MACH,CAAC,GAAG,IAAI,YAAY,SAAS;AAAA,QAC3B,GAAI,IAAI,YAAY,oBAAoB;AAAA,UACtC,kBAAkB,EAAE,GAAG,IAAI,YAAY,iBAAiB;AAAA,QAC1D;AAAA,QACA,GAAI,IAAI,YAAY,gBAAgB,EAAE,cAAc,EAAE,GAAG,IAAI,YAAY,aAAa,EAAE;AAAA,QACxF,GAAI,IAAI,YAAY,mBAAmB;AAAA,UACrC,iBAAiB,EAAE,GAAG,IAAI,YAAY,gBAAgB;AAAA,QACxD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,sBAAsB,OAAO,SAAqC;AAC7E,QAAM,EAAE,SAAS,IAAI,UAAM,iCAAY,IAAI;AAC3C,SAAO;AACT;AAEO,IAAM,4BAA4B,CAAC,MAAmB,QAAwB;AACnF,QAAM,EAAE,iBAAiB,IAAI,KAAK;AAClC,SAAO,OAAO,qBAAqB,WAAW,OAAO,KAAK,gBAAgB,EAAE,SAAS;AACvF;;;AC3BO,IAAM,2BAA2B,CAAC,gBAA0C;AACjF,MAAI,uBAAuB;AAC3B,MAAI;AACJ,MAAI;AAEJ,KAAG;AACD,sBAAkB;AAElB,eAAW,OAAO,OAAO,KAAK,WAAW,GAAG;AAC1C,YAAM,0BAA0B,0BAA0B,sBAAsB,GAAG;AAEnF,4BAAsB,0BAA0B,sBAAsB,GAAG;AACzE,YAAM,wBAAwB,qBAAqB,KAAK;AAExD,UACE,OAAO,0BAA0B,aAChC,OAAO,KAAK,qBAAqB,EAAE,SAAS,KAC3C,OAAO,KAAK,mBAAmB,EAAE,SAAS,IAC5C;AACA,+BAAuB;AAAA,UACrB,GAAG;AAAA,UACH,CAAC,MAAM;AAAA,YACL,kBAAkB,SAAS;AAAA,cACzB,GAAG;AAAA,cACH,GAAG;AAAA,YACL,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AACA,YAAM,sBAAsB,0BAA0B,sBAAsB,GAAG;AAE/E,UAAI,4BAA4B,qBAAqB;AACnD,0BAAkB;AAAA,MACpB;AAAA,IACF;AAAA,EACF,SAAS;AACT,SAAO;AACT;;;AJrCO,IAAM,QAAQ,YAA2B;AAC9C,QAAM,WAAW,MAAM,oBAAoB,GAAG;AAC9C,QAAM,cAAc,qBAAqB,QAAQ;AACjD,QAAM,uBAAuB,yBAAyB,WAAW;AACjE,EAAO,KAAK,KAAK,cAAU,8BAAK,aAAa,oBAAoB,GAAG,QAAW,CAAC,CAAC;AACnF;;;AKLA,IAAI;AACF,QAAM,OAAO,QAAQ,KAAK,MAAM,CAAC;AAEjC,MAAI,KAAK,OAAO,OAAO;AACrB,IAAO,KAAK,iBAAiB;AAAA,EAC/B;AAEA,MAAI,KAAK,OAAO,SAAS;AACvB,IAAO,KAAK,mBAAmB;AAC/B,UAAM;AAAA,EACR;AAEA,MAAI,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS;AAC5C,IAAO,MAAM,WAAW,KAAK,yDAAyD;AACtF,UAAM,IAAI,UAAU,CAAC;AAAA,EACvB;AACA,EAAO,KAAK,SAAS;AACvB,SAASC,QAAP;AACA,MAAIA,kBAAiB,WAAW;AAC9B,YAAQ,KAAKA,OAAM,IAAI;AAAA,EACzB,WAAW,OAAOA,WAAU,UAAU;AACpC,IAAO,MAAMA,MAAK;AAClB,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;","names":["chalk","util","error"]}